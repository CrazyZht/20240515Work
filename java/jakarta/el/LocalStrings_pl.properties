# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

beanNameELResolver.beanReadOnly=Nazwa komponentu bean [{0}] jest dostępna tylko do odczytu

elProcessor.defineFunctionInvalidClass=Klasa [{0}] nie jest publiczna
elProcessor.defineFunctionInvalidMethod=Metoda [{0}] w klasie [{1}] nie jest publiczną metodą statyczną
elProcessor.defineFunctionInvalidParameterList=Lista parametrów [{0}] dla metody [{1}] w klasie [{2}] jest niepoprawna
elProcessor.defineFunctionInvalidParameterTypeName=Typ parametru [{0}] dla metody [{1}] w klasie [{2}] jest niepoprawny
elProcessor.defineFunctionNoMethod=Nie można znaleźć publicznej metody statycznej [{0}] w klasie [{1}]
elProcessor.defineFunctionNullParams=Co najmniej jeden parametr wejściowy miał wartość NULL

expressionFactory.cannotCreate=Nie można utworzyć fabryki wyrażeń typu [{0}]
expressionFactory.cannotFind=Nie znaleziono fabryki wyrażeń typu [{0}]
expressionFactory.readFailed=Odczytanie [{0}] nie powiodło się

importHandler.ambiguousImport=Nie można zaimportować klasy [{0}], ponieważ powoduje ona konflikt z klasą [{1}], która została już zaimportowana
importHandler.ambiguousStaticImport=Nie można przetworzyć importu statycznego [{0}], ponieważ powoduje on konflikt z klasą [{1}], która została już zaimportowana
importHandler.classNotFound=Nie można zaimportować klasy [{0}], ponieważ nie można jej znaleźć
importHandler.invalidClass=Klasa [{0}] musi być publiczna, musi znajdować się w wyeksportowanym pakiecie (dla Java 9+), nie może być klasą abstrakcyjną i nie może być interfejsem
importHandler.invalidClassName=Nazwa klasy do zaimportowania [{0}] musi zawierać pakiet
importHandler.invalidClassNameForStatic=Klasa [{0}] określona dla importu statycznego [{1}] jest niepoprawna
importHandler.invalidStaticName=Nazwa metody statycznej lub pola do zaimportowania [{0}] musi zawierać klasę
importHandler.staticNotFound=Nie można znaleźć importu statycznego [{0}] w klasie [{1}] dla importu [{2}]

lambdaExpression.tooFewArgs=Podano następującą liczbę argumentów dla wyrażenia lambda: [{0}], a wymagana jest co najmniej następująca liczba: [{1}]

objectNotAssignable=Nie można dodać obiektu typu [{0}] do tablicy obiektów typu [{1}]
propertyNotFound=Nie znaleziono właściwości [{1}] w typie [{0}]
propertyNotReadable=Nie można odczytać właściwości [{1}] w typie [{0}]
propertyNotWritable=Nie można zapisać właściwości [{1}] w typie [{0}]
propertyReadError=Błąd podczas odczytywania [{1}] w typie [{0}]
propertyWriteError=Błąd podczas zapisywania [{1}] w typie [{0}]

staticFieldELResolver.methodNotFound=Nie znaleziono zgodnej publicznej metody statycznej o nazwie [{0}] w klasie [{1}]
staticFieldELResolver.notFound=Nie znaleziono publicznego pola statycznego o nazwie [{0}] w klasie [{1}] (wyeksportowanej dla Java 9+)
staticFieldELResolver.notWritable=Zapisywanie w polach statycznych (w tym przypadku w polu [{0}] w klasie [{1}]) jest niedozwolone

util.method.ambiguous=Nie można znaleźć jednoznacznej metody: {0}.{1}({2})
util.method.notfound=Nie znaleziono metody: {0}.{1}({2})

